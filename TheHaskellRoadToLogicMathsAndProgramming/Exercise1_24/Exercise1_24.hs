-- checks whether potentialDivisor divides numberToBeDivided
doesDivide :: Integer -> Integer -> Bool
doesDivide potentialDivisor numberToBeDivided = rem numberToBeDivided potentialDivisor == 0

-- convenience function
-- brutally goes from a given k to n^(0.5)
leastNaturalDivisor' :: [Integer] -> Integer -> Integer
leastNaturalDivisor' (potentialDivisorsHead:potentialDivisorsTail) ofANumber
    | doesDivide potentialDivisorsHead ofANumber = potentialDivisorsHead
    | potentialDivisorsHead^2 > ofANumber = ofANumber
    | otherwise = leastNaturalDivisor' potentialDivisorsTail ofANumber

-- find the least natural divisor of a number
-- instead of starting from 2, use a collection of primes generated by primes1
-- At first glance function indeed looks weird:
-- it used to take an Integer as a parameter and return an Integer.
-- Now, since we removed the parameter (and its usage) from the definition,
-- the function means something else. Now it reads:
-- "I take no parameters and return a function transforming Integers into Integers".
-- Type declaration stays unchanged and the fact that we ever needed "ofANumber" seems silly now.
-- Magic!
leastNaturalDivisor :: Integer -> Integer
leastNaturalDivisor = leastNaturalDivisor' primes1

-- is the number's least natural divisor that very same number?
prime :: Integer -> Bool
prime potentialPrime
    | potentialPrime < 1 = error "Not a positive integer."
    | potentialPrime == 1 = False
    | otherwise = leastNaturalDivisor potentialPrime == potentialPrime

primes1 :: [Integer]
primes1 = 2 : filter prime [3..1000000] -- changed the range to be finite

main = do
    print $ primes1
